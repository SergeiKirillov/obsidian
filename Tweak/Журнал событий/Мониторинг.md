---
url:
  - https://www.outsidethebox.ms/22879/
tags:
  - powershell
  - windows
  - журнал
---
## Идея – мониторинг журнала событий
[Известно](https://www.outsidethebox.ms/12241/#event), что при выходе из сна в журнал **Система** (System) пишется событие с кодом **1** от источника **Microsoft-Windows-Power-Troubleshooter**.
## О различных типах журналов событий в Windows
![](images/Pasted%20image%2020260301082531.png)
- **Журналы Windows**. Это старые журналы: Приложения, Безопасность, Установка, Система и что-то еще по мелочи.
- **Журналы приложений и служб**. Десятки новых журналов появились в Windows Vista. Они работают на основе [ETW](https://learn.microsoft.com/en-us/windows-hardware/drivers/devtest/event-tracing-for-windows--etw-) и событий .NET.

## Мониторинг журналов Windows
Выход из сна регистрируется в журнале Система. Для журналов Windows быстро нашлись два родственных способа:
- [создание фонового задания PowerShell](https://web.archive.org/web/20210312161823/https:/community.idera.com/database-tools/powershell/powertips/b/tips/posts/responding-to-new-event-log-entries-part-2) для мониторинга журнала с помощью [класса EventLog](https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.eventlog)
- регистрация события WMI ([временная](https://learn-powershell.net/2013/08/02/powershell-and-events-wmi-temporary-event-subscriptions/) или [постоянная](https://learn-powershell.net/2013/08/14/powershell-and-events-permanent-wmi-event-subscriptions/)) для отслеживания системных событий
Мне приглянулся первый вариант, потому что в примере нужно был лишь поменять название журнала, ИД и источник события. Я лишь слегка заточил его под выход из сна.
### Скрипт
Командлет **Register-ObjectEvent** по сути [создает фоновое задание](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/register-objectevent?view=powershell-7.2#example-2-specify-an-action-to-respond-to-an-event) (PowerShell job).
   
```powershell
# Запускать от администратора
# Журнал (Get-EventLog -AsString)
$log =[System.Diagnostics.EventLog]'System'
$log.EnableRaisingEvents=$true

# Имя фонового задания
$jobname='ResumeFromSleep'

 # Действия при появлении события 
 $action   = { 
     # Путь к файлу с отловленными событиями 
     $logFile   =   "C:\temp\ResumeFromSleep.txt" 
     $entry   =   $Event  .SourceEventArgs.Entry    
     # Искомое событие: ID 1 от 'Microsoft-Windows-Power-Troubleshooter' 
     if   (  $entry  .EventId   -eq   1   -and   $entry  .Source   -eq   'Microsoft-Windows-Power-Troubleshooter'  ) { 
         # Сообщение 
         $msg   =   "Resumed from sleep: event $($entry.EventId) from $($entry.Source) is: $($entry.Message)"        
         $msg   |   Out-File   -Append   -FilePath   $logFile   -Encoding   Unicode         
         Write-Host   $msg 
     } 
 } 
 # Отменяем регистрацию предыдущих фоновых заданий с таким же именем 
 Unregister-Event   -SourceIdentifier   $jobname   -ErrorAction   SilentlyContinue 
 # Регистрируем и запускаем фоновую задачу 
 $job   =   Register-ObjectEvent   -InputObject   $log   -EventName   EntryWritten   -SourceIdentifier   $jobname   -Action   $action 
 Receive-Job   $job 
 Write-Host   "Monitoring started for Event ID 1 (Power-Troubleshooter)." 
 # Необязательно: блокируем появление приглашения на ввод следующей команды 
 # Имеет смысл только для выполнения в консоли 
 while   (  $true  ) {   Start-Sleep   -Seconds   1 } 
 <# остановка мониторинга и полное удаление фонового задания 
 Get-Job -Name 'ResumeFromSleep' | Stop-Job -PassThru | Remove-Job 
 #> 
```   
При наступлении события (выходе из сна) его свойства выводятся на экран и выполняется запись в текстовый файл, что вы можете легко изменить под свои нужды.
